/* 
 * SCCS IDENTIFICATION
 * copyright (C) 2000, 2000 by zhl.
 * MUST be distributed in source form only.
 */

/*************************************************************************************************
 * File            : orasf.pc                                                                    *
 * System Name     : StarRing                                                                    *
 * VERSION         : 1.1                                                                         *
 * LANGUAGE        : ESQLC                                                                       *
 * OS & ENVIROMENT : SCO UNIX  5                                                                 * 
 *                   ORACLE  7.3.4                                                               *
 * DESCRIPTION     : this program refer to all of functions about                                * 
 *                   operation of database( oracle sql function)                                 *
 * HISTORY:                                                                                      *
 * MM/DD/YYYY      ADDRESS          PROGRAMMER            DESCRIPTION                            *
 *-----------------------------------------------------------------------------------------------*
 * 10/12/2000      BEIJING          ZOLA                  Creat                                  *
 * 04/10/2008      BeiJing          Chenff                Modify INCLUDE sqlca.h to SQLCA        *  
 *                                                                                               *
 *************************************************************************************************/


#include <arcbcl.h>
#include <arclog.h>
#include <__arcde.h>

/*
#include <sqlca.h>
#include <sqlda.h>
#include <sqlcpr.h>
*/

/* chenff 20090410 sqlca.h change to SQLCA */
EXEC SQL INCLUDE SQLCA;
EXEC SQL INCLUDE SQLDA;
EXEC SQL INCLUDE SQLCPR;

/*  Application include file define using different type */

#include <__pladb.h>
#include <arctrc.h>

extern int         get_comma_num   _(( char * , char ));

extern short MAX_VAR_NUM;
extern tSqlValue * TSQLVarPool;

extern short MAX_AREA;
extern short CURRENT_AREA;
extern short FETCH_AREA;
extern tSqlStru ** TSQLSTRU;

extern long FAP_SQLCODE;

/* Global variable definition */
EXEC SQL BEGIN DECLARE SECTION;
    char CONNECT_NAME[64]="conn00";
EXEC SQL END DECLARE SECTION;

/*------------------------------------------------------------------------*
 *  Function Name : int  OraMallocArea()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraMallocArea()
{
   int i;
   char alloc_stat;
   char *desc_id_in;
   char *desc_id_out;
   tSqlValue *tv;
   int  max_num;

   if ( CURRENT_AREA < MAX_AREA-1 )
       CURRENT_AREA++;
   else {
       bclerreg( E_MAXAREA, _FL_, CURRENT_AREA + 1 );
       return E_FAIL;
   }

   i = CURRENT_AREA;

   if( TSQLSTRU == NULL )
      APP_ERR( E_DB_NOOPEN )

   if ( TSQLSTRU[ CURRENT_AREA ] == NULL ) {
       TSQLSTRU[ CURRENT_AREA ] = calloc( 1, sizeof( tSqlStru ) );
       if ( TSQLSTRU[ CURRENT_AREA ] == NULL ) {
          bclerreg( E_ALLOC, _FL_, sizeof( tSqlStru ) );
          return E_FAIL;
       }
   }

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
   alloc_stat = TSQLSTRU[CURRENT_AREA]->tsqlstat.alloc_stat;
   desc_id_in = TSQLSTRU[CURRENT_AREA]->desc_id_in;
   desc_id_out = TSQLSTRU[CURRENT_AREA]->desc_id_out;
   /* 20051027 不再释放tValuepb */
   tv = TSQLSTRU[CURRENT_AREA]->tValuepb;
   max_num = TSQLSTRU[CURRENT_AREA]->max_num;

   memset( TSQLSTRU[ CURRENT_AREA ], 0x00 , sizeof( tSqlStru ) );

   TSQLSTRU[CURRENT_AREA]->tsqlstat.alloc_stat = alloc_stat;
   TSQLSTRU[CURRENT_AREA]->desc_id_in = desc_id_in;
   TSQLSTRU[CURRENT_AREA]->desc_id_out = desc_id_out;
   TSQLSTRU[CURRENT_AREA]->tValuepb = tv;
   TSQLSTRU[CURRENT_AREA]->max_num = max_num;

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  OraFreeArea()                                    *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraFreeArea()
{
   int i;

   i = CURRENT_AREA;
   if ( CURRENT_AREA > 0 ) {

      if ( TSQLSTRU[ CURRENT_AREA ] != NULL )
          OraSqlDBFree( CURRENT_AREA );
      CURRENT_AREA--;
   }

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  OraFreeAreaD()                                   *
 *  Description   : dtaname   DTA名称                                     *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraFreeAreaD( char *dtaname )
{
   int i;

   i = CURRENT_AREA;
   if ( CURRENT_AREA > 0 ) {

      if ( TSQLSTRU[ CURRENT_AREA ] != NULL ) {
          bcl_log( "DBDBG.log", _FL_, "DTA[%s]执行语句[%s]的工作区[%d]未释放", dtaname, TSQLSTRU[CURRENT_AREA]->sql_str, CURRENT_AREA );
          OraSqlDBFree( CURRENT_AREA );
      }
      CURRENT_AREA--;
   }

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  FreeValueBuf()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
void
FreeValueBuf(tSqlStru *_sqlstru)
{

    if ( _sqlstru->tValuepb != NULL )   {
/*
        free( _sqlstru->tValuepb );
        _sqlstru->tValuepb = NULL;
*/
        _sqlstru->tV_num = 0;
    }

}

void
FreeCValue( tSqlValue * _sqlvalue )
{
    switch ( _sqlvalue->type ) {
     case DFFAPCHAR:
     case DFFAPDATE:
     case DFFAPVCHAR2:
          if( _sqlvalue->pubdata.c_value != NULL ) {
              free( _sqlvalue->pubdata.c_value );
              _sqlvalue->pubdata.c_value = NULL;
          }
          break;
    }
}

/*------------------------------------------------------------------------*
 *  Function Name : int  AllocValueBuf()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
AllocValueBuf(tSqlStru *_sqlstru,int _alloc_num)
{
/* 20051027 只calloc一次
    FreeValueBuf( _sqlstru );
    _sqlstru->tValuepb= \
         (tSqlValue *) calloc ((size_t) _alloc_num,(size_t) sizeof(tSqlValue) );
*/
    if( _sqlstru->tValuepb == NULL ) {
        _sqlstru->tValuepb= \
         (tSqlValue *) malloc ((size_t) _alloc_num*(size_t) sizeof(tSqlValue) );
        _sqlstru->max_num = _alloc_num;
    }
    else if( _alloc_num > _sqlstru->max_num ){
        _sqlstru->tValuepb= \
         (tSqlValue *) realloc ( _sqlstru->tValuepb, \
                  (size_t) _alloc_num*(size_t) sizeof(tSqlValue) );
        _sqlstru->max_num = _alloc_num;
    }
    if( _sqlstru->tValuepb == NULL ) {
        bclerreg( E_ALLOC, _FL_, _alloc_num * sizeof( tSqlValue ) );
        return E_FAIL;
    }
    memset(_sqlstru->tValuepb,0x00,sizeof(tSqlValue) * _alloc_num );
    _sqlstru->tV_num = _alloc_num;
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  OraPutData  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int OraPutData ( int _data_id , int _data_type , void * _data )
{
    char str_data[MAX_DOUBLE_STR_LEN];

    int str_len;

    if ( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    if ( _data_id > ( MAX_VAR_NUM/2 - 1 ) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    FreeCValue( &TSQLVarPool[ _data_id ] );
    switch ( _data_type )   {
     case DFFAPCHAR:
     case DFFAPVCHAR2:
     case DFFAPDATE:
          if( _data_type == DFFAPVCHAR2 )
              str_len = DEF_VARCHAR_LEN;
          else
              str_len = strlen( ( char *)_data ) + 1;

          TSQLVarPool[ _data_id ].pubdata.c_value = calloc( 1, str_len + 1 );
          if ( TSQLVarPool[ _data_id ].pubdata.c_value == NULL ) {
              bclerreg( E_ALLOC, _FL_, str_len + 1 );
              return E_FAIL;
          }

          TSQLVarPool[ _data_id ].cb = str_len;
          memcpy( TSQLVarPool[ _data_id ].pubdata.c_value, _data, str_len );

          trc_db_data_rec( 0, _data_id, _data_type, "CHAR", _data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPSMINT:
          TSQLVarPool[ _data_id ].pubdata.s_value = *( (short *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
/* ADD BY PENGBIN */
          TSQLVarPool[ _data_id ].pubdata.l_value = *( (short *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
/* ADD END */
          sprintf( str_data, "%d", *( (short *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type,  "SMALLINT2", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
/* 20050428 支持DFFAPINTEGER */
     case DFFAPINTEGER:
          _data_type = DFFAPINT;
          TSQLVarPool[ _data_id ].pubdata.l_value = *( (int *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
          sprintf( str_data, "%d", *( (int *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "INT4", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPINT:
          TSQLVarPool[ _data_id ].pubdata.l_value = *( (long *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
          sprintf( str_data, "%ld", *( (long *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "INT8", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPDECIMAL:
          TSQLVarPool[ _data_id ].pubdata.l_value = *( (long *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
          sprintf( str_data, "%ld", *( (long *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "INT8", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPFLOAT:
          TSQLVarPool[ _data_id ].pubdata.d_value = *( (double *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
          sprintf( str_data, "%lf", *( (double *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "FLOAT8", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPSMFLOAT:
          TSQLVarPool[ _data_id ].pubdata.f_value = *( (float *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_DATA_LEN;
          sprintf( str_data, "%f", *( (float *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "SMALLFLOAT4", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     default:
          trc_db_data_rec( 0, _data_id, _data_type, "NODEFTYPE", \
                              "", 0 );
          APP_ERR( E_NODEF_TYPE )
    }

    TSQLVarPool[ _data_id ].type = _data_type;
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  OraGetData  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int OraGetData ( int _data_id , void * _data , int _len )
{
    char str_data[MAX_DOUBLE_STR_LEN];
    int  len;

    if ( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    _data_id = _data_id + ( MAX_VAR_NUM/2 );
    if ( _data_id > (MAX_VAR_NUM-1) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    switch ( TSQLVarPool[ _data_id ].type ) {
     case DFFAPCHAR:
     case DFFAPVCHAR2:
     case DFFAPDATE:
          len = TSQLVarPool[_data_id].cb < _len?TSQLVarPool[_data_id].cb:_len;
          memcpy( _data, TSQLVarPool[ _data_id ].pubdata.c_value , len );
          if ( len < _len )
              ((char *)_data)[len] = 0x0;
          bcl_rtrim( ( char * ) _data );
          bcl_ltrim( ( char * ) _data );
          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              TSQLVarPool[ _data_id ].pubdata.c_value, 
                              TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPSMINT:
     case DFFAPINT:
     case DFFAPDECIMAL:
          if( _len == sizeof( short ) )
              *( (short *)_data ) =
                        (short)TSQLVarPool[ _data_id ].pubdata.l_value;
          else if( _len == sizeof( int ) )
              *( (int *)_data ) =
                        ( int )TSQLVarPool[ _data_id ].pubdata.l_value;
          else
              *( (long *)_data ) =
                        ( long )TSQLVarPool[ _data_id ].pubdata.l_value;
          sprintf( str_data, "%ld", TSQLVarPool[ _data_id ].pubdata.l_value );
          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
     case DFFAPFLOAT:
     case DFFAPSMFLOAT:
          if( _len == sizeof( float ) )
              *( (float *)_data ) = TSQLVarPool[ _data_id ].pubdata.d_value;
          else
              *( (double *)_data ) = TSQLVarPool[ _data_id ].pubdata.d_value;
          sprintf( str_data, "%lf", TSQLVarPool[ _data_id ].pubdata.d_value );
          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
    }

    return( E_OK );
}

int OraGetType ( int _data_id , short *_type )
{
    _data_id = _data_id + ( MAX_VAR_NUM/2 );
    if ( _data_id > (MAX_VAR_NUM-1) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    switch ( TSQLVarPool[ _data_id ].type ) {
     case DFFAPCHAR:
     case DFFAPVCHAR2:
     case DFFAPDATE:
          *_type = DSTRING;
          break;
     case DFFAPSMINT:
          *_type = DSHORT;
          break;
     case DFFAPINT:
          *_type = DLONG;
          break;
     case DFFAPDECIMAL:
          *_type = DDOUBLE;
          break;
     case DFFAPFLOAT:
          *_type = DDOUBLE;
          break;
     case DFFAPSMFLOAT:
          *_type = DFLOAT;
          break;
    }

    return( E_OK );
}

/*------------------------------------------------------------------------*
 *  Function Name : void  OraGetDBErr  ()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

void OraGetDBErr ( int _area )
{
    
    if ( TSQLSTRU == NULL )
        return;

    if ( TSQLSTRU[_area] == NULL )
        return;

    TSQLSTRU[_area]->sql_code = sqlca.sqlcode;

/*oracle没有isam_code
    TSQLSTRU[_area]->isam_code = sqlca.sqlerrd[1];
*/
    TSQLSTRU[_area]->isam_code = 0;

    TSQLSTRU[_area]->proc_row = sqlca.sqlerrd[2];
    TSQLSTRU[_area]->proc_row=sqlca.sqlerrd[2];
    sprintf( TSQLSTRU[_area]->user_msg, "Errmsg[%70s]:Offset[%d]", \
             sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrd[4] );
} 

/*------------------------------------------------------------------------*
 *  Function Name : int  OraSqlSetConnect  ()                             *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

void
OraSqlSetConnect( char * _con_name )
{
    strcpy( CONNECT_NAME, _con_name );
    return;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  OraSqlOpenDB  ()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int
OraSqlOpenDB  ( int _control_num,...)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char          h_db_name[20];
         char          h_server_name[20];
         char          h_passwd[20];
         char          h_connect[60];
    EXEC SQL END DECLARE SECTION;
    va_list ap;
    int i;
    int _area=0;
    char sql_str[SQLSTRLEN];

    FAP_SQLCODE = 0;
    memset(h_db_name,0x00,sizeof(h_db_name));
    memset(h_server_name,0x00,sizeof(h_server_name));
    memset(h_passwd,0x00,sizeof(h_passwd));
    va_start(ap,_control_num);
    for(i=0;i<_control_num;i++)  {
        switch(i)   {
            case 0:
                strcpy(h_db_name,va_arg( ap, char * ) );
                break;
            case 1:
                strcpy(h_server_name,va_arg(ap,char *));
                break;
            case 2:
                strcpy(h_passwd,va_arg(ap,char *));
                break;
        }
    }
    va_end(ap);

    i = strlen( h_server_name );
    if( i > 0 ) {
        sprintf( h_connect, "%s", h_server_name );
        if( h_connect[i-1] != '/' && strlen(h_passwd) > 0 )
            strcat( h_connect, "/" );
    }
    else
        strcpy( h_connect, "/" );

    if( strlen( h_passwd ) > 0 )
        strcat( h_connect, h_passwd );
    if( strlen( h_db_name ) > 0 ) {
        strcat( h_connect, "@" );
        strcat( h_connect, h_db_name );
    }

    trc_db_rec( NULL, 0 );
    EXEC SQL CONNECT :h_connect AT :CONNECT_NAME;
    sprintf( sql_str, "CONNECT :%s AT :%s", h_connect, CONNECT_NAME );
    trc_db_rec( sql_str, sqlca.sqlcode );

    if ( TSQLVarPool == NULL ) {
       TSQLVarPool = (tSqlValue * )calloc( 1, sizeof( tSqlValue ) * (MAX_VAR_NUM+1) );
       if ( TSQLVarPool == NULL ) {
          bclerreg( E_OSCALL, _FL_, "calloc TSQLVarPool error" );
          return E_FAIL;
       }
    }
    if ( TSQLSTRU == NULL ) {
       TSQLSTRU = (tSqlStru **)calloc( 1, sizeof( tSqlStru * ) * (MAX_AREA+1) );
       if ( TSQLSTRU == NULL ) {
          bclerreg( E_OSCALL , _FL_, "calloc TSQLSTRU error" );
          return E_FAIL;
       }
    }
    if ( TSQLSTRU[0] == NULL ) {
        TSQLSTRU[0] = calloc( 1, sizeof(tSqlStru) );
       if ( TSQLSTRU[0] == NULL ) {
          bclerreg( E_OSCALL , _FL_, "calloc TSQLSTRU[0] error" );
          return E_FAIL;
       }
    }

    OraGetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );

}

/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlCloseDB ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
OraSqlCloseDB ( void )
{
    int _area=0;
    int i;
    char sql_str[SQLSTRLEN];

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
    for( i=0; i<MAX_AREA; i++ )
        if( TSQLSTRU[i] != NULL )
            if( TSQLSTRU[i]->tsqlstat.alloc_stat ) {
                OraSqlDealloc( TSQLSTRU[i] );
                TSQLSTRU[i]->tsqlstat.alloc_stat = 0;
            }

    while( OraFreeArea() );
    trc_db_rec( NULL, 0 );
    EXEC SQL AT :CONNECT_NAME COMMIT RELEASE;
    sprintf( sql_str, "AT :%s COMMIT RELEASE", CONNECT_NAME );
    trc_db_rec( sql_str, sqlca.sqlcode );

    OraGetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );
    
}


/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlBeginWork ()                                *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlBeginWork ( void )
{
    char sql_str[SQLSTRLEN];

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    sprintf( sql_str, "AT :%s BEGIN WORK", CONNECT_NAME );
    trc_db_rec( NULL, 0 );
    trc_db_rec( sql_str, 0 );

    return( E_OK );

}

/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlCommit()                                    *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlCommit ( void )
{
    char sql_str[SQLSTRLEN];
    int _area=0;

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    trc_db_rec( NULL, 0 );
    EXEC SQL AT :CONNECT_NAME COMMIT WORK;
    sprintf( sql_str, "AT :%s COMMIT WORK", CONNECT_NAME );
    trc_db_rec( sql_str, sqlca.sqlcode );
    OraGetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );

}

/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlRollBack  ()                                *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlRollBack  ( void )
{
    char sql_str[SQLSTRLEN];
    int _area=0;

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    trc_db_rec( NULL, 0 );
    EXEC SQL AT :CONNECT_NAME ROLLBACK WORK;
    sprintf( sql_str, "AT :%s ROLLBACK WORK", CONNECT_NAME );
    trc_db_rec( sql_str, sqlca.sqlcode );
    OraGetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );
    
}


/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlDBFree  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlDBFree  ( int _area )
{
    int ret;

    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    FreeValueBuf( TSQLSTRU[_area] );
    if( TSQLSTRU[_area]->tsqlstat.cur_openstat )
        ret = OraSqlCloseCur( TSQLSTRU[_area] );
    if( TSQLSTRU[_area]->tsqlstat.prep_stat )
        ret = OraSqlFreePrep( TSQLSTRU[_area] );

    if( TSQLSTRU[_area]->tsqlstat.cur_allocstat )
        ret = OraSqlFreeCur( TSQLSTRU[_area] );

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
/*
    if( TSQLSTRU[_area]->tsqlstat.alloc_stat )
        ret = OraSqlDealloc( TSQLSTRU[_area] );
*/

    TSQLSTRU[_area]->sql_code = 0;
    TSQLSTRU[_area]->user_code = 0;

    TSQLSTRU[_area]->ques_num = 0;
    TSQLSTRU[_area]->tsqlstat.put_stat = 0;
    strcpy( TSQLSTRU[_area]->user_msg , "" );
    strcpy( TSQLSTRU[_area]->sql_str, "" );

    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlSelect  ()                                  *
 *  Description   :                                                       *
 *  Input         : _area 工作区号  1 -- MAX_AREA (1-10)                  *
 *                : _statement 查询语句                                   *
 *                : _op_flag 游标操作方式 0 - NEXT                        *
 *                :                       P - PREVIOUS                    *
 *                :                       A - ABSOLUTE                    *
 *                :                       C - CURRENT                     *
 *                :                       F - FIRST                       *
 *                :                       L - LAST                        *
 *                :                       R - RELATIVE                    *
 *                :                       D - DOUBLE                      *
 *                : _offset 游标的偏移量                                  *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlSelect ( int _area , char * _statement , char _op_flag , long _offset )
{
    char        prepname[15];
    char        cursname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];
    tSqlValue	*sql_value;

    FAP_SQLCODE = 0;
    sprintf( prepname,"%d",_area );
    sprintf( cursname,"C%d",_area );
    sprintf( descname,"%d",_area );

    if( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if( _area >= MAX_AREA || TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

/* 已fetch的工作区可直接继续fetch */
    if( !TSQLSTRU[_area]->tsqlstat.cur_fetchstat ) {
        alloc_num = get_comma_num( _statement , ',' )+1;

        ret = OraSqlPrepare( TSQLSTRU[_area] , prepname, _statement);
        if( ret != E_OK )
            return ret;

        ret = OraSqlDeclare( TSQLSTRU[_area] , cursname,  _op_flag );
        if ( ret != E_OK )
            return ret;

        if( alloc_num < DEF_ALLOC_NUM )
            alloc_num = DEF_ALLOC_NUM;
        else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
                OraSqlDealloc( TSQLSTRU[_area] );
                TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
            }

        ret = OraSqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
        if( ret != E_OK )
            return ret;

        /**it is for bind variables ***/
        ret = OraSqlDescribe( TSQLSTRU[_area], _op_flag );
        if ( ret != E_OK )
            return ret;

        /* 为查询条件赋值 */
        if( TSQLSTRU[_area]->ques_num != 0 )  {
            ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
            if ( ret != E_OK )
                return ret;

            for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
                memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ] ,sizeof( tSqlValue ) );
                ret = OraSqlPutValue( TSQLSTRU[_area] , (short)i );
                if ( ret != E_OK )
                    return ret;
            } /* end of for */
        } /* end of if ques_num */

        ret = OraSqlOpenCur( TSQLSTRU[_area] );
        if ( ret != E_OK )
            return ret;

        /**it is for select list ***/
        ret = OraSqlDescribe( TSQLSTRU[_area], _op_flag );
        if ( ret != E_OK )
            return ret;

    } /* end of if fetchstat */

    TSQLSTRU[_area]->op_flag = _op_flag;
    ret = OraSqlFetchCur( TSQLSTRU[_area] , _offset );
    if( ret != E_OK )
        return ret;

    /* 为查询结果赋值 */
    ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->column_num );
    if( ret != E_OK )
        return ret;

    for( i = 1; i <= TSQLSTRU[_area]->column_num ; i++ ) {
         ret = OraSqlGetValue( TSQLSTRU[_area] , (short)i );
         if( ret != E_OK )
            return ret;
         sql_value = &TSQLVarPool[ i+(MAX_VAR_NUM/2)-1 ];
         FreeCValue( sql_value );
       
         memcpy( sql_value, &TSQLSTRU[_area]->tValuepb[i-1],sizeof(tSqlValue));
    }

    FETCH_AREA = _area;
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int OraSqlExec  ()                                    *
 *  Description   : 使用默认工作区0                                       *
 *  Input         :                                                       *
 *                : _statement 查询语句                                   *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
OraSqlExec ( char * _statement )
{
    int         _area=0;             /* 使用默认工作区0  */ 
    char        prepname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(descname,"%d",_area);

    if( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if( TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

    alloc_num = get_comma_num( _statement , '?' )+1;

    ret = OraSqlPrepare( TSQLSTRU[_area] , prepname, _statement );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    if ( alloc_num < DEF_ALLOC_NUM )
        alloc_num = DEF_ALLOC_NUM;
    else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
            OraSqlDealloc( TSQLSTRU[_area] );
            TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
        }
    ret = OraSqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    /*添加特别为了oracle*/
    ret = OraSqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }
    /*添加end*/

    /* 为查询条件赋值 */
    if( TSQLSTRU[_area]->ques_num != 0 )  {
        ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
        if ( ret != E_OK ) {
           OraSqlDBFree( _area );
           return ret;
        }
        for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
             memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ] ,sizeof( tSqlValue ) );
            ret = OraSqlPutValue( TSQLSTRU[_area] ,(short)i );
            if( ret != E_OK ) {
                OraSqlDBFree( _area );
                return ret;
            }
        } /* end of for */
   } /* end of if ques_num */

   ret = OraSqlExecute( TSQLSTRU[_area] );
   OraSqlDBFree( _area );
   if( ret != E_OK )
        return ret;

/* 20051027 提高效率
    strncpy( str_tmp, _statement, 10 );
    bcl_str_toupper( str_tmp );
    if ( TSQLSTRU[_area]->proc_row == 0 && strstr(str_tmp,"CREATE")== NULL\
                && strstr(str_tmp,"DROP")== NULL)
       return E_NOTFOUND;
*/
    if ( TSQLSTRU[_area]->proc_row == 0 )
       return E_NOTFOUND;

   return E_OK;
}


/*------------------------------------------------------------------------*
 *  Function Name : void  OraGetStru  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int OraGetStru ( int _data_id , void * _data , int _len )
{
    tSqlValue	* sql_value;
    int		i;
    void	*p;

    if ( _data == NULL )
        APP_ERR( E_DB_NOOPEN )

    p = _data;

    for( i = _data_id ; i < TSQLSTRU[FETCH_AREA]->column_num ; i++ ) {
        sql_value = &TSQLSTRU[FETCH_AREA]->tValuepb[i];
        switch ( sql_value->type ) {
             case DFFAPRAW:
             case DFFAPLONG:
             case DFFAPLONGRAW:
             case DFFAPCHAR:
             case DFFAPVCHAR2:
                  STRALIGN( p , sizeof( char ) );
                  OraGetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( char ) * ( sql_value->cb + 1 ));
                  break;
             case DFFAPDATE:
                  STRALIGN( p , sizeof( char ) );
                  OraGetData( i , p , DEF_DATE_LEN );
                  p = (void *)((long)p + sizeof( char ) * ( DEF_DATE_LEN + 1 ));
                  break;
             case DFFAPSMINT:
                  STRALIGN( p , sizeof( short ) );
                  OraGetData( i , p , sizeof( short ) );
                  p = (void *)((long)p + sizeof( short ));
                  break;
             case DFFAPINT:
             case DFFAPNUMBER:
                  STRALIGN( p , sizeof( long ) );
                  OraGetData( i , p , sizeof( long ) );
                  p = (void *)((long)p + sizeof( long ));
                  break;
             case DFFAPDECIMAL:
             case DFFAPFLOAT:
                  STRALIGN( p , sizeof( double ) );
                  OraGetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( double ));
                  break;
             case DFFAPSMFLOAT:
                  STRALIGN( p , sizeof( float ) );
                  OraGetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( float ));
                  break;
        }
/* 长度 = sizeof ( STRUCT ) */
        if( (long)p - (long)_data >= _len )
            break;
    }
    return( E_OK );
}

/*------------------------------------------------------------------------*
 *  Function Name : void  OraGetTabDesc()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int OraGetTabDesc( char * _tab_name , int * _len )
{
    EXEC SQL BEGIN DECLARE SECTION;
         short         h_get_serial;
         char          h_get_name[20];
         int           h_get_type;
         int           h_get_length;
         char          prepname[15];
         char          cursname[15];
         char          descname[15];
    EXEC SQL END DECLARE SECTION;
    char	_statement[SQLSTRLEN];
    int         ret;
    int         alloc_num=0;
    int		_area=0;
    int		data_id=0;

    int		i;

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(cursname,"C%d",_area);
    sprintf(descname,"%d",_area);
    sprintf( _statement , "select * from %s where 1=0" , _tab_name );

    ret = OraSqlPrepare( TSQLSTRU[_area] , prepname, _statement );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    ret = OraSqlDeclare( TSQLSTRU[_area] , cursname,  0 );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

/* Oracle需要先分配输入缓冲区，无论是否有输入 */
    if( alloc_num < DEF_ALLOC_NUM )
        alloc_num = DEF_ALLOC_NUM;
    else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
            OraSqlDealloc( TSQLSTRU[_area] );
            TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
        }

    ret = OraSqlAllocate( TSQLSTRU[_area] , descname , DEF_ALLOC_NUM );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    ret = OraSqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    ret = OraSqlOpenCur( TSQLSTRU[_area] );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    ret = OraSqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        OraSqlDBFree( _area );
        return ret;
    }

    data_id =  MAX_VAR_NUM/2;
    for( i = data_id; i < TSQLSTRU[_area]->column_num + data_id ; i++ ) {
/* 20050526需要释放字符串类型，否则type改变后无法释放 */
        FreeCValue( &TSQLVarPool[ i ] );

        h_get_serial = i + 1 - data_id ;
        
        h_get_type = (((SQLDA *)(TSQLSTRU[_area]->desc_id_out))->T)[h_get_serial-1];
        h_get_length = (((SQLDA *)(TSQLSTRU[_area]->desc_id_out))->L)[h_get_serial-1];

        memset( h_get_name, 0x00, sizeof( h_get_name ) );

        strncpy( h_get_name, (((SQLDA *)(TSQLSTRU[_area]->desc_id_out))->S)[h_get_serial-1], (((SQLDA *)(TSQLSTRU[_area]->desc_id_out))->C)[h_get_serial-1] );

        strcpy( TSQLVarPool[ i ].name, h_get_name );        
        TSQLVarPool[ i ].type = h_get_type;
        TSQLVarPool[ i ].cb = h_get_length;
    }

    *_len = TSQLSTRU[_area]->column_num;

    OraSqlDBFree( _area );
    return( E_OK );

}

/*------------------------------------------------------------------------*
 *  Function Name : void  OraPutStru  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/

int OraPutStru ( char * _tab_name , int _data_id , void * _data , int _len )
{
    int         ret;
    int		i, col_num;
    void	*p;
    tSqlValue	* sql_value;

    if( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    p = _data;

    ret = OraGetTabDesc( _tab_name , &col_num );
    if( ret != E_OK ) {
        bclerreg( E_SQL , _FL_ , "OraGetTabDesc err.");
        return ret;
    }

    for( i = _data_id; i < col_num + _data_id ; i++ ) {
        sql_value = &TSQLVarPool[ i + MAX_VAR_NUM/2 - _data_id ];
        switch ( sql_value->type ) {
             case DFFAPRAW:
             case DFFAPLONG:
             case DFFAPLONGRAW:
             case DFFAPCHAR:
             case DFFAPVCHAR2:
                  STRALIGN( p , sizeof( char ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( char ) * ( sql_value->cb + 1 ));
                  break;
             case DFFAPDATE:
                  STRALIGN( p , sizeof( char ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( char ) * ( DEF_DATE_LEN + 1 ));
                  break;
             case DFFAPSMINT:
                  STRALIGN( p , sizeof( short ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( short ));
                  break;
             case DFFAPINT:
             case DFFAPNUMBER:
                  STRALIGN( p , sizeof( long ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( long ));
                  break;
             case DFFAPDECIMAL:
             case DFFAPFLOAT:
                  STRALIGN( p , sizeof( double ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( double ));
                  break;
             case DFFAPSMFLOAT:
                  STRALIGN( p , sizeof( float ) );
                  OraPutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( float ));
                  break;
        }
/* 长度 = sizeof ( STRUCT ) */
        if( (long)p - (long)_data >= _len )
            break;
    }

    return( E_OK );
}

/* 20051027 支持批量处理insert/update提高效率 */
int
OraSqlBatExec ( int _area , char * _statement )
{
    char        prepname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(descname,"%d",_area);

    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if ( _area >= MAX_AREA || TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

/* 已prepare的工作区可直接继续Exec */
    if ( !TSQLSTRU[_area]->tsqlstat.prep_stat ) {
        alloc_num = get_comma_num( _statement , ',' )+1;
        ret = OraSqlPrepare( TSQLSTRU[_area] , prepname, _statement );
        if ( ret != E_OK ) {
            bclerreg( E_SQL , _FL_ ,"OraSqlPrepare err.");
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

        if ( alloc_num < DEF_ALLOC_NUM )
            alloc_num = DEF_ALLOC_NUM;
        else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
            OraSqlDealloc( TSQLSTRU[_area] );
            TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
        }

        ret = OraSqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
        if ( ret != E_OK ) {
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

        /* 取?个数和填充INPUT SQLDA */
        ret = OraSqlDescribe( TSQLSTRU[_area], '0' );
        if( ret != E_OK ) {
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

/* 为查询条件赋值 */
        if( TSQLSTRU[_area]->ques_num != 0 )  {
            ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
            if ( ret != E_OK ) {
                bclerreg( E_SQL , _FL_ ,"AllocValueBuf err.");
                TSQLSTRU[_area]->sql_code = 0;
                TSQLSTRU[_area]->user_code = 0;
                return ret;
            }

            for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
                memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ], \
                        sizeof( tSqlValue ) );
                ret = OraSqlPutValue( TSQLSTRU[_area] , (short)i );
                if ( ret != E_OK ) {
                    bclerreg( E_SQL , _FL_ ,"OraSqlPutValue err.");
                    TSQLSTRU[_area]->sql_code = 0;
                    TSQLSTRU[_area]->user_code = 0;
                    return ret;
                }
            } /* end of for */

        } /* end of if ques_num */

    } /* end of if prep_stat */
    else
        for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
            memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ], \
                    sizeof( tSqlValue ) );
            ret = OraSqlPutValue( TSQLSTRU[_area] , (short)i );
            if ( ret != E_OK ) {
                bclerreg( E_SQL , _FL_ ,"OraSqlPutValue err.");
                TSQLSTRU[_area]->sql_code = 0;
                TSQLSTRU[_area]->user_code = 0;
                return ret;
            }
        } /* end of for */
    ret = OraSqlExecute( TSQLSTRU[_area] );
    TSQLSTRU[_area]->tsqlstat.put_stat = 0;
    TSQLSTRU[_area]->sql_code = 0;
    TSQLSTRU[_area]->user_code = 0;
    if ( ret == E_FAIL ) {
        bclerreg( E_SQL , _FL_ ,"OraSqlExecute err.");
        return ret;
    }

    if ( TSQLSTRU[_area]->proc_row == 0 )
       return E_NOTFOUND;
    return E_OK;
}


