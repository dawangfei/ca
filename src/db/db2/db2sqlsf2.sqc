/*
 *    Copyright (c) 2001-2003 ADTEC Ltd.
 *    All rights reserved
 *
 *    This is unpublished proprietary source code of ADTEC Ltd.
 *    The copyright notice above does not evidence any actual
 *    or intended publication of such source code.
 *
 *    NOTICE: UNAUTHORIZED DISTRIBUTION, ADAPTATION OR USE MAY BE
 *    SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
 */

/*
 *    ProgramName : db2sqlsf.sqc
 *    SystemName  : StarRing
 *    Version     : 3.0
 *    Language    : C
 *    OS & Env    : RedHat Linux 9.0
                    DB2    8.1.0.0
 *    Description : DB2二层封装函数
 *    History     : 
 *    YYYY/MM/DD        Position        Author         Description
 *    -------------------------------------------------------------
 *    2003/10/26        BeiJing         Handq          Creation
 */

#include <arcbcl.h>
#include <arclog.h>
#include <__arcde.h>

#include <sql.h>
#include <sqlenv.h>
#include <sqlda.h>
#include <sqlca.h>

/*  Application include file define using different type */
#include <__pladb.h>
#include <arctrc.h>

extern int         get_comma_num   _(( char * , char ));

extern short MAX_VAR_NUM;
extern tSqlValue * TSQLVarPool;

extern short MAX_AREA;
extern short CURRENT_AREA;
extern short FETCH_AREA;
extern tSqlStru ** TSQLSTRU;

extern long FAP_SQLCODE;

/* Global variable definition */
static struct sqlca sqlca;
static char err_msg[ERR_MSG_LEN+1];

/*Function in this program define*/

/*------------------------------------------------------------------------*
 *  Function Name : int  Db2MallocArea()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2MallocArea( void )
{
   int i;
   char alloc_stat;
   char *desc_id_in;
   char *desc_id_out;
   char *desc_id_tmp;
   tSqlValue *tv;
   int  max_num;

   if ( CURRENT_AREA < MAX_AREA-1 )
       CURRENT_AREA++;
   else {
       bclerreg( E_MAXAREA, _FL_, CURRENT_AREA + 1 );
       return E_FAIL;
   }

   i = CURRENT_AREA;

   if( TSQLSTRU == NULL )
      APP_ERR( E_DB_NOOPEN )

   if ( TSQLSTRU[ CURRENT_AREA ] == NULL ) {
       TSQLSTRU[ CURRENT_AREA ] = calloc( 1, sizeof( tSqlStru ) );
       if ( TSQLSTRU[ CURRENT_AREA ] == NULL ) {
          bclerreg( E_ALLOC, _FL_, sizeof( tSqlStru ) );
          return E_FAIL;
       }
   }

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
   alloc_stat = TSQLSTRU[CURRENT_AREA]->tsqlstat.alloc_stat;
   desc_id_in = TSQLSTRU[CURRENT_AREA]->desc_id_in;
   desc_id_out = TSQLSTRU[CURRENT_AREA]->desc_id_out;
   desc_id_tmp = TSQLSTRU[CURRENT_AREA]->desc_id_tmp;
   /* 20051027 不再释放tValuepb */
   tv = TSQLSTRU[CURRENT_AREA]->tValuepb;
   max_num = TSQLSTRU[CURRENT_AREA]->max_num;

   memset( TSQLSTRU[ CURRENT_AREA ], 0x00 , sizeof( tSqlStru ) );

   TSQLSTRU[CURRENT_AREA]->tsqlstat.alloc_stat = alloc_stat;
   TSQLSTRU[CURRENT_AREA]->desc_id_in = desc_id_in;
   TSQLSTRU[CURRENT_AREA]->desc_id_out = desc_id_out;
   TSQLSTRU[CURRENT_AREA]->desc_id_tmp = desc_id_tmp;
   TSQLSTRU[CURRENT_AREA]->tValuepb = tv;
   TSQLSTRU[CURRENT_AREA]->max_num = max_num;

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  Db2FreeArea()                                    *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2FreeArea( void )
{
   int i;

   i = CURRENT_AREA;
   if ( CURRENT_AREA > 0 ) {

      if ( TSQLSTRU[ CURRENT_AREA ] != NULL )
          Db2SqlDBFree( CURRENT_AREA );
      CURRENT_AREA--;
   }

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  Db2FreeAreaD()                                   *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2FreeAreaD( char *dtaname )
{
   int i;

   i = CURRENT_AREA;
   if ( CURRENT_AREA > 0 ) {

      if ( TSQLSTRU[ CURRENT_AREA ] != NULL ) {
          /*
          bcl_log( "DBDBG.log", _FL_, "DTA[%s]执行语句[%s]的工作区[%d]未释放", dtaname, TSQLSTRU[CURRENT_AREA]->sql_str, CURRENT_AREA );
          */
          Db2SqlDBFree( CURRENT_AREA );
      }
      CURRENT_AREA--;
   }

   return i;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  FreeValueBuf()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
void
FreeValueBuf(tSqlStru *_sqlstru)
{

    if ( _sqlstru->tValuepb != NULL )   {
/* 20051027 不再反复释放、分配，提高效率
        free( _sqlstru->tValuepb );
        _sqlstru->tValuepb = NULL;
*/
        _sqlstru->tV_num = 0;
    }

}

static void
FreeCValue( tSqlValue * _sqlvalue )
{
    switch ( _sqlvalue->type ) {
        case DFFAPCHAR:
        case DFFAPVCHAR:
        case DFFAPLONG:
        case DFFAPVCHAR2:
        case DFFAPDATE:
        case DFFAPDTIME:
        case DFFAPINTERVAL:
        case DFFAPTEXT:
        case DFFAPBYTES:
          if( _sqlvalue->pubdata.c_value != NULL ) {
              free( _sqlvalue->pubdata.c_value );
              _sqlvalue->pubdata.c_value = NULL;
          }
          break;
    }
}

/*------------------------------------------------------------------------*
 *  Function Name : int  AllocValueBuf()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
AllocValueBuf( tSqlStru *_sqlstru,int _alloc_num )
{
/* 20051027 只calloc一次
    FreeValueBuf( _sqlstru );
    _sqlstru->tValuepb= \
         (tSqlValue *) calloc ((size_t) _alloc_num,(size_t) sizeof(tSqlValue) );
*/

    if( _sqlstru->tValuepb == NULL ) {
        _sqlstru->tValuepb= \
         (tSqlValue *) malloc ((size_t) _alloc_num*(size_t) sizeof(tSqlValue) );
        _sqlstru->max_num = _alloc_num;
    }
    else if( _alloc_num > _sqlstru->max_num ){
        _sqlstru->tValuepb= \
         (tSqlValue *) realloc ( _sqlstru->tValuepb, \
                  (size_t) _alloc_num*(size_t) sizeof(tSqlValue) );
        _sqlstru->max_num = _alloc_num;
    }
    if( _sqlstru->tValuepb == NULL ) {
        bclerreg( E_ALLOC, _FL_, _alloc_num * sizeof( tSqlValue ) );
        return E_FAIL;
    }
    memset(_sqlstru->tValuepb,0x00,sizeof(tSqlValue) * _alloc_num );
    _sqlstru->tV_num = _alloc_num;
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  Db2PutData  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
Db2PutData ( int _data_id , int _data_type , void * _data )
{
    char str_data[MAX_DOUBLE_STR_LEN];
    int str_len;

    if ( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    if ( _data_id > ( MAX_VAR_NUM/2 - 1 ) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    FreeCValue( &TSQLVarPool[ _data_id ] );
    TSQLVarPool[ _data_id ].type = _data_type;
    switch ( _data_type )   {
        case DFFAPCHAR:
        case DFFAPVCHAR:
        case DFFAPLONG:
        case DFFAPVCHAR2:
        case DFFAPDATE:
        case DFFAPDTIME:
        case DFFAPINTERVAL:
        case DFFAPTEXT:
        case DFFAPBYTES:
          if( _data_type == DFFAPTEXT || _data_type == DFFAPBYTES )
              str_len = DEF_CHAR_LEN;
          else {
              TSQLVarPool[ _data_id ].type = DFFAPVCHAR2;
              str_len = strlen( ( char *)_data ) + 1;
          }

          TSQLVarPool[ _data_id ].pubdata.c_value = calloc( 1, str_len + 1 );
          if ( TSQLVarPool[ _data_id ].pubdata.c_value == NULL ) {
              bclerreg( E_ALLOC, _FL_, str_len + 1 );
              return E_FAIL;
          }

          TSQLVarPool[ _data_id ].cb = str_len;
          memcpy( TSQLVarPool[ _data_id ].pubdata.c_value, _data, str_len );

          trc_db_data_rec( 0, _data_id, _data_type, "CHAR", _data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPSMINT:
          TSQLVarPool[ _data_id ].pubdata.s_value = *( (short *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_SMINT_LEN;

          sprintf( str_data, "%d", *( (short *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type,  "SMALLINT2", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPINTEGER:
          TSQLVarPool[ _data_id ].pubdata.i_value = *( (int *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_INTEGER_LEN;

          sprintf( str_data, "%d", *( (int *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "INT4", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPINT:
          TSQLVarPool[ _data_id ].pubdata.l_value = *( (long *)_data );
          TSQLVarPool[ _data_id ].cb = DEF_BIGINT_LEN;

          sprintf( str_data, "%ld", *( (long *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "INT8", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPDECIMAL:
        case DFFAPFLOAT:
          TSQLVarPool[ _data_id ].pubdata.d_value = *( (double *)_data );
          TSQLVarPool[ _data_id ].cb = sizeof( double );

          sprintf( str_data, "%lf", *( (double *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "FLOAT8", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPSMFLOAT:
          TSQLVarPool[ _data_id ].pubdata.f_value = *( (float *)_data );
          TSQLVarPool[ _data_id ].cb = sizeof( float );

          sprintf( str_data, "%f", *( (float *)_data ) );
          trc_db_data_rec( 0, _data_id, _data_type, "SMALLFLOAT4", \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        default:
          trc_db_data_rec( 0, _data_id, _data_type, "NODEFTYPE", \
                              "", 0 );
          APP_ERR( E_NODEF_TYPE )
    }

    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  Db2GetData  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
Db2GetData ( int _data_id , void * _data , int _len )
{
    char str_data[MAX_DOUBLE_STR_LEN];
    int  len;

    if ( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    _data_id = _data_id + ( MAX_VAR_NUM/2 );
    if ( _data_id > (MAX_VAR_NUM-1) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    switch ( TSQLVarPool[ _data_id ].type ) {
        case DFFAPCHAR:
        case DFFAPVCHAR:
        case DFFAPLONG:
        case DFFAPVCHAR2:
        case DFFAPDATE:
        case DFFAPDTIME:
        case DFFAPINTERVAL:
        case DFFAPTEXT:
        case DFFAPBYTES:
          len = TSQLVarPool[_data_id].cb < _len?TSQLVarPool[_data_id].cb:_len;
          memcpy( _data, TSQLVarPool[ _data_id ].pubdata.c_value , len );
          if ( len < _len )
              ((char *)_data)[len] = 0x0;

          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              TSQLVarPool[ _data_id ].pubdata.c_value, 
                              TSQLVarPool[ _data_id ].cb );
          break;
/* 20051014 handq 统一使用l_value/d_value */
        case DFFAPSMINT:
        case DFFAPINTEGER:
        case DFFAPINT:
          if( _len == sizeof( short ) ) {
              *((short *)_data) = (short)TSQLVarPool[_data_id].pubdata.l_value;
              sprintf( str_data, "%d", TSQLVarPool[ _data_id ].pubdata.l_value);
          }
          else {
              if( _len == sizeof( int ) ) {
                  *((int *)_data) = (int)TSQLVarPool[_data_id].pubdata.l_value;
                  sprintf( str_data, "%d", TSQLVarPool[ _data_id ].pubdata.l_value);
              }
              else {
                  *((long *)_data)=(long)TSQLVarPool[_data_id].pubdata.l_value;
                  sprintf( str_data, "%ld", TSQLVarPool[ _data_id ].pubdata.l_value);
              }
          }
          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
        case DFFAPSMFLOAT:
        case DFFAPFLOAT:
        case DFFAPDECIMAL:
          if( _len == sizeof( float ) ) {
              *( (float *)_data ) = TSQLVarPool[ _data_id ].pubdata.d_value;
              sprintf( str_data, "%f", TSQLVarPool[ _data_id ].pubdata.d_value);
          }
          else {
              *( (double *)_data ) = TSQLVarPool[ _data_id ].pubdata.d_value;
              sprintf( str_data, "%lf", TSQLVarPool[ _data_id ].pubdata.d_value);
          }
          trc_db_data_rec( 1, _data_id - ( MAX_VAR_NUM/2 ), \
                              TSQLVarPool[ _data_id ].type, \
                              TSQLVarPool[ _data_id ].name, \
                              str_data, TSQLVarPool[ _data_id ].cb );
          break;
    }

    return( E_OK );
}

int
Db2GetType ( int _data_id , short * _type )
{
    _data_id = _data_id + ( MAX_VAR_NUM/2 );
    if ( _data_id > (MAX_VAR_NUM-1) ) {
        bclerreg( E_INVALARG, _FL_, "data id" );
        return E_FAIL;
    }

    switch ( TSQLVarPool[ _data_id ].type ) {
        case DFFAPCHAR:
        case DFFAPVCHAR:
        case DFFAPLONG:
        case DFFAPVCHAR2:
        case DFFAPDATE:
        case DFFAPDTIME:
        case DFFAPINTERVAL:
          *_type = DBINARY;
          break;
        case DFFAPTEXT:
        case DFFAPBYTES:
          *_type = DSTRING;
          break;
        case DFFAPSMINT:
          *_type = DSHORT;
          break;
        case DFFAPINTEGER:
          *_type = DINT;
          break;
        case DFFAPINT:
          *_type = DLONG;
          break;
        case DFFAPSMFLOAT:
          *_type = DFLOAT;
          break;
        case DFFAPFLOAT:
        case DFFAPDECIMAL:
          *_type = DDOUBLE;
          break;
    }

    return( E_OK );
}
/*------------------------------------------------------------------------*
 *  Function Name : void  Db2GetDBErr  ()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
void
Db2GetDBErr ( int _area )
{

    if ( TSQLSTRU == NULL )
        return;

    if ( TSQLSTRU[_area] == NULL )
        return;

    TSQLSTRU[_area]->sql_code = sqlca.sqlcode;

/*Db2没有isam_code
    TSQLSTRU[_area]->isam_code = sqlca.sqlerrd[1];
*/
    TSQLSTRU[_area]->isam_code = 0;

    TSQLSTRU[_area]->proc_row = sqlca.sqlerrd[2];
} 

/*------------------------------------------------------------------------*
 *  Function Name : int  Db2SqlSetConnect  ()                             *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
void
Db2SqlSetConnect( char * _con_name )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char db_name[64];
    EXEC SQL END DECLARE SECTION;
    char sql_str[SQLSTRLEN];

    strcpy( db_name, _con_name );
    FAP_SQLCODE = 0;
    trc_db_rec( NULL, 0 );
    EXEC SQL SET CONNECTION :db_name;
    sprintf( sql_str, "SET CONNECTION :%s", db_name );
    trc_db_rec( sql_str, sqlca.sqlcode );
    FAP_SQLCODE = sqlca.sqlcode;

    return;
}

/*------------------------------------------------------------------------*
 *  Function Name : int  Db2SqlOpenDB  ()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
Db2SqlOpenDB( int _control_num,...)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char          h_db_name[20];
         char          h_server_name[20];
         char          h_passwd[20];
    EXEC SQL END DECLARE SECTION;
    va_list ap;
    int i;
    int _area=0;
    char sql_str[SQLSTRLEN];

    FAP_SQLCODE = 0;
    memset(h_db_name,0x00,sizeof(h_db_name));
    memset(h_server_name,0x00,sizeof(h_server_name));
    memset(h_passwd,0x00,sizeof(h_passwd));
    va_start(ap,_control_num);
    for(i=0;i<_control_num;i++)  {
        switch(i)   {
            case 0:
                strcpy(h_db_name,va_arg( ap, char * ) );
                break;
            case 1:
                strcpy(h_server_name,va_arg(ap,char *));
                break;
            case 2:
                strcpy(h_passwd,va_arg(ap,char *));
                break;
        }
    }
    va_end(ap);

    if( strlen( h_server_name ) == 0 ) {
        trc_db_rec( NULL, 0 );
        EXEC SQL CONNECT TO :h_db_name;
        sprintf( sql_str, "CONNECT TO :%s", h_db_name );
    }
    else {
        trc_db_rec( NULL, 0 );
        EXEC SQL CONNECT TO :h_db_name USER :h_server_name USING :h_passwd;
        sprintf( sql_str, "CONNECT TO :%s USER :%s USING :%s", \
                                       h_db_name, h_server_name, h_passwd );
    }
    trc_db_rec( sql_str, sqlca.sqlcode );

    if ( TSQLVarPool == NULL ) {
       TSQLVarPool = (tSqlValue * )calloc( 1, sizeof( tSqlValue ) * (MAX_VAR_NUM+1) );
       if ( TSQLVarPool == NULL ) {
          bclerreg( E_OSCALL, _FL_, "calloc TSQLVarPool error" );
          return E_FAIL;
       }
    }
    if ( TSQLSTRU == NULL ) {
       TSQLSTRU = (tSqlStru **)calloc( 1, sizeof( tSqlStru * ) * (MAX_AREA+1) );
       if ( TSQLSTRU == NULL ) {
          bclerreg( E_OSCALL , _FL_, "calloc TSQLSTRU error" );
          return E_FAIL;
       }
    }
    if( TSQLSTRU[0] == NULL ) {
        TSQLSTRU[0] = calloc( 1, sizeof(tSqlStru) );
        if( TSQLSTRU[0] == NULL ) {
            bclerreg( E_OSCALL , _FL_, "calloc TSQLSTRU[0] error" );
            return E_FAIL;
        }
    }

    Db2GetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );

    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlCloseDB ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
Db2SqlCloseDB( void )
{
    int _area=0;
    int i;

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
    for( i=0; i<MAX_AREA; i++ )
        if( TSQLSTRU[i] != NULL )
            if( TSQLSTRU[i]->tsqlstat.alloc_stat == 1 ) {
                Db2SqlDealloc( TSQLSTRU[i] );
                TSQLSTRU[i]->tsqlstat.alloc_stat = 0;
            }

    while( Db2FreeArea() );
    trc_db_rec( NULL, 0 );
    EXEC SQL ROLLBACK WORK;

    trc_db_rec( "ROLLBACK WORK", sqlca.sqlcode );
    EXEC SQL CONNECT RESET;
    trc_db_rec( "CONNECT RESET", sqlca.sqlcode );

    Db2GetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );

    return E_OK;
}


/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlBeginWork ()                                *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlBeginWork( void )
{
    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    trc_db_rec( NULL, 0 );
    trc_db_rec( "BEGIN WORK", 0 );
    return( E_OK );

}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlCommit()                                    *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlCommit ( void )
{
    int _area=0;

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    trc_db_rec( NULL, 0 );
    EXEC SQL COMMIT WORK;
    trc_db_rec( "COMMIT WORK", sqlca.sqlcode );
    Db2GetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );

    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlRollBack  ()                                *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlRollBack  ( void )
{
    int _area=0;

    FAP_SQLCODE = 0;
    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    trc_db_rec( NULL, 0 );
    EXEC SQL ROLLBACK WORK;
    trc_db_rec( "ROLLBACK WORK", sqlca.sqlcode );
    Db2GetDBErr( _area );
    DB_ERR( TSQLSTRU[_area] );
    
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlDBFree  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlDBFree( int _area )
{
    int ret;

    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    FreeValueBuf( TSQLSTRU[_area] );
    if( TSQLSTRU[_area]->tsqlstat.cur_openstat )
        ret = Db2SqlCloseCur( TSQLSTRU[_area] );
    if( TSQLSTRU[_area]->tsqlstat.prep_stat )
        ret = Db2SqlFreePrep( TSQLSTRU[_area] );

    if( TSQLSTRU[_area]->tsqlstat.cur_allocstat )
        ret = Db2SqlFreeCur( TSQLSTRU[_area] );

   /* 20030815 handq 优化SQLDA区只在CloseDB时释放 */
/*
    if( TSQLSTRU[_area]->tsqlstat.alloc_stat )
        ret = Db2SqlDealloc( TSQLSTRU[_area] );
*/
    TSQLSTRU[_area]->sql_code = 0;
    TSQLSTRU[_area]->user_code = 0;

    TSQLSTRU[_area]->ques_num = 0;
    TSQLSTRU[_area]->tsqlstat.put_stat = 0;
    strcpy( TSQLSTRU[_area]->user_msg , "" );
    strcpy( TSQLSTRU[_area]->sql_str , "" );

    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlSelect  ()                                  *
 *  Description   :                                                       *
 *  Input         : _area 工作区号  1 -- MAX_AREA (1-10)                  *
 *                : _statement 查询语句                                   *
 *                : _op_flag 游标操作方式 0 - NEXT                        *
 *                :                       P - PREVIOUS                    *
 *                :                       A - ABSOLUTE                    *
 *                :                       C - CURRENT                     *
 *                :                       F - FIRST                       *
 *                :                       L - LAST                        *
 *                :                       R - RELATIVE                    *
 *                :                       D - DOUBLE                      *
 *                : _offset 游标的偏移量                                  *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlSelect ( int _area , char * _statement , char _op_flag , long _offset )
{
    char        prepname[15];
    char        cursname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];
    tSqlValue	*sql_value;

    FAP_SQLCODE = 0;
    sprintf( prepname,"%d",_area );
    sprintf( cursname,"C%d",_area );
    sprintf( descname,"%d",_area );

    if( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if( _area >= MAX_AREA || TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

/* 已fetch的工作区可直接继续fetch */
    if( !TSQLSTRU[_area]->tsqlstat.cur_fetchstat ) {
        alloc_num = get_comma_num( _statement , ',' )+1;

        ret = Db2SqlPrepare( TSQLSTRU[_area] , prepname, _statement);
        if( ret != E_OK )
            return ret;

        ret = Db2SqlDeclare( TSQLSTRU[_area] , cursname,  _op_flag );
        if ( ret != E_OK )
            return ret;

        if( alloc_num < DEF_ALLOC_NUM )
            alloc_num = DEF_ALLOC_NUM;
        else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
                Db2SqlDealloc( TSQLSTRU[_area] );
                TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
            }

        ret = Db2SqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
        if( ret != E_OK )
            return ret;

        /**it is for bind variables ***/
        ret = Db2SqlDescribe( TSQLSTRU[_area], _op_flag );
        if ( ret != E_OK )
            return ret;

        /* 为查询条件赋值 */
        if( TSQLSTRU[_area]->ques_num != 0 )  {
            ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
            if ( ret != E_OK )
                return ret;

            for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
                memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ] ,sizeof( tSqlValue ) );
                ret = Db2SqlPutValue( TSQLSTRU[_area] , (short)i );
                if ( ret != E_OK )
                    return ret;
            } /* end of for */
        } /* end of if ques_num */

        ret = Db2SqlOpenCur( TSQLSTRU[_area] );
        if ( ret != E_OK )
            return ret;

        /**it is for select list ***/
        ret = Db2SqlDescribe( TSQLSTRU[_area], _op_flag );
        if ( ret != E_OK )
            return ret;

    } /* end of if fetchstat */

    TSQLSTRU[_area]->op_flag = _op_flag;
    ret = Db2SqlFetchCur( TSQLSTRU[_area] , _offset );
    if( ret != E_OK )
        return ret;

    /* 为查询结果赋值 */
    ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->column_num );
    if( ret != E_OK )
        return ret;

    for( i = 1; i <= TSQLSTRU[_area]->column_num ; i++ ) {
         ret = Db2SqlGetValue( TSQLSTRU[_area] , (short)i );
         if( ret != E_OK )
            return ret;
         sql_value = &TSQLVarPool[ i+(MAX_VAR_NUM/2)-1 ];
         FreeCValue( sql_value );
         memcpy( sql_value, &TSQLSTRU[_area]->tValuepb[i-1],sizeof(tSqlValue));
    }

    FETCH_AREA = _area;
    return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : int Db2SqlExec  ()                                    *
 *  Description   : 使用默认工作区0                                       *
 *  Input         :                                                       *
 *                : _statement 查询语句                                   *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int 
Db2SqlExec ( char * _statement )
{
    int         _area=0;             /* 使用默认工作区0  */ 
    char        prepname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(descname,"%d",_area);

    if( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if( TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

    alloc_num = get_comma_num( _statement , '?' )+1;

    ret = Db2SqlPrepare( TSQLSTRU[_area] , prepname, _statement );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    if ( alloc_num < DEF_ALLOC_NUM )
        alloc_num = DEF_ALLOC_NUM;
    else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
        Db2SqlDealloc( TSQLSTRU[_area] );
        TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
    }
    ret = Db2SqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    /* 取?个数和填充INPUT SQLDA */
    ret = Db2SqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    /* 为查询条件赋值 */
    if( TSQLSTRU[_area]->ques_num != 0 )  {
        ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
        if ( ret != E_OK ) {
           Db2SqlDBFree( _area );
           return ret;
        }
        for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
            memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ] ,sizeof( tSqlValue ) );
            ret = Db2SqlPutValue( TSQLSTRU[_area] ,(short)i );
            if( ret != E_OK ) {
                Db2SqlDBFree( _area );
                return ret;
            }
        } /* end of for */
   } /* end of if ques_num */

   ret = Db2SqlExecute( TSQLSTRU[_area] );
   Db2SqlDBFree( _area );
   if( ret != E_OK )
       return ret;

/* 20051027 提高效率
    strncpy( str_tmp, _statement, 10 );
    bcl_str_toupper( str_tmp );
    if ( TSQLSTRU[_area]->proc_row == 0 && strstr(str_tmp,"CREATE")== NULL\
                && strstr(str_tmp,"DROP")== NULL)
       return E_NOTFOUND;
*/
   if ( TSQLSTRU[_area]->proc_row == 0 )
       return E_NOTFOUND;

   return E_OK;
}

/*------------------------------------------------------------------------*
 *  Function Name : void  Db2GetTabDesc()                                 *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int Db2GetTabDesc( char * _tab_name , int * _len )
{
    EXEC SQL BEGIN DECLARE SECTION;
         short         h_get_serial;
         char          h_get_name[20];
         short         h_get_type;
         short         h_get_length;
         char          prepname[15];
         char          cursname[15];
         char          descname[15];
    EXEC SQL END DECLARE SECTION;
    char	_statement[SQLSTRLEN];
    int         ret;
    int         alloc_num=0;
    int		_area=0;
    int		data_id=0;

    int		i;

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(cursname,"C%d",_area);
    sprintf(descname,"%d",_area);
    sprintf( _statement , "select * from %s where 1=0" , _tab_name );

    ret = Db2SqlPrepare( TSQLSTRU[_area] , prepname, _statement );
    if( ret != E_OK ) {
        return ret;
    }

    ret = Db2SqlDeclare( TSQLSTRU[_area] , cursname,  0 );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

/* Db2需要先分配输入缓冲区，无论是否有输入 */
    if( alloc_num < DEF_ALLOC_NUM )
        alloc_num = DEF_ALLOC_NUM;
    else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
            Db2SqlDealloc( TSQLSTRU[_area] );
            TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
        }

    ret = Db2SqlAllocate( TSQLSTRU[_area] , descname , DEF_ALLOC_NUM );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    ret = Db2SqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    ret = Db2SqlOpenCur( TSQLSTRU[_area] );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    ret = Db2SqlDescribe( TSQLSTRU[_area], '0' );
    if( ret != E_OK ) {
        Db2SqlDBFree( _area );
        return ret;
    }

    data_id =  MAX_VAR_NUM/2;
    for( i = data_id; i < TSQLSTRU[_area]->column_num + data_id ; i++ ) {
/* 20050526需要释放字符串类型，否则type改变后无法释放 */
        FreeCValue( &TSQLVarPool[ i ] );

        h_get_serial = i + 1 - data_id ;
        
        h_get_type = (((struct sqlda *)(TSQLSTRU[_area]->desc_id_tmp))->sqlvar)[h_get_serial-1].sqltype;
        h_get_length = (((struct sqlda *)(TSQLSTRU[_area]->desc_id_tmp))->sqlvar)[h_get_serial-1].sqllen;

        memset( h_get_name, 0x00, sizeof( h_get_name ) );

        strncpy( h_get_name, (((struct sqlda *)(TSQLSTRU[_area]->desc_id_out))->sqlvar)[h_get_serial-1].sqlname.data, (((struct sqlda *)(TSQLSTRU[_area]->desc_id_out))->sqlvar)[h_get_serial-1].sqlname.length );

        strcpy( TSQLVarPool[ i ].name, h_get_name );        
/* 20050430对于not null字段h_get_type为定义值-1的偶数,需要转换成定义类型 */
        if( !(h_get_type % 2) )
            h_get_type += 1;
        if( h_get_type == DFFAPFLOAT && h_get_length == sizeof( float ) )
            h_get_type = DFFAPSMFLOAT;
        TSQLVarPool[ i ].type = h_get_type;
        TSQLVarPool[ i ].cb = h_get_length;
    }

    *_len = TSQLSTRU[_area]->column_num;

    Db2SqlDBFree( _area );
    return( E_OK );

}

/*------------------------------------------------------------------------*
 *  Function Name : void  Db2PutStru  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int Db2PutStru ( char * _tab_name , int _data_id , void * _data , int _len )
{
    int         ret;
    int		i, col_num;
    void	*p;
    tSqlValue	* sql_value;

    if( _data == NULL ) {
        bclerreg( E_INVALARG, _FL_, "data buffer null" );
        return E_FAIL;
    }

    p = _data;

    ret = Db2GetTabDesc( _tab_name , &col_num );
    if( ret != E_OK ) {
        bclerreg( E_SQL , _FL_ , "Db2GetTabDesc err.");
        return ret;
    }

    for( i = _data_id; i < col_num + _data_id ; i++ ) {
        sql_value = &TSQLVarPool[ i + MAX_VAR_NUM/2 - _data_id ];
        switch ( sql_value->type ) {
             case DFFAPDATE:
             case DFFAPDTIME:
             case DFFAPINTERVAL:
             case DFFAPCHAR:
             case DFFAPVCHAR:
             case DFFAPLONG:
             case DFFAPVCHAR2:
                  STRALIGN( p , sizeof( char ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( char ) * ( sql_value->cb + 1 ));
                  break;
             case DFFAPTEXT:
             case DFFAPBYTES:
                  STRALIGN( p , sizeof( char ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( char ) * ( DEF_CHAR_LEN + 1 ));
                  break;
             case DFFAPSMINT:
                  STRALIGN( p , sizeof( short ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( short ));
                  break;
             case DFFAPINTEGER:
/* 20051019 统一按long处理，方便移植
                  STRALIGN( p , sizeof( int ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( int ));
                  break;
*/
             case DFFAPINT:
                  STRALIGN( p , sizeof( long ) );
                  Db2PutData( i , DFFAPINT , p );
                  p = (void *)((long)p + sizeof( long ));
                  break;
             case DFFAPDECIMAL:
             case DFFAPFLOAT:
                  STRALIGN( p , sizeof( double ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( double ));
                  break;
             case DFFAPSMFLOAT:
                  STRALIGN( p , sizeof( float ) );
                  Db2PutData( i , sql_value->type , p );
                  p = (void *)((long)p + sizeof( float ));
                  break;
        }
/* 长度 = sizeof ( STRUCT ) */
        if( (long)p - (long)_data >= _len )
            break;
    }

    return( E_OK );
}

/*------------------------------------------------------------------------*
 *  Function Name : void  Db2GetStru  ()                                  *
 *  Description   :                                                       *
 *  Input         :                                                       *
 *  Output        :                                                       *
 *------------------------------------------------------------------------*/
int
Db2GetStru ( int _data_id , void * _data , int _len )
{
    tSqlValue	* sql_value;
    int		i;
    void	*p;

    if ( _data == NULL )
        APP_ERR( E_DB_NOOPEN )

    p = _data;

    for( i = _data_id ; i < TSQLSTRU[FETCH_AREA]->column_num ; i++ ) {
        sql_value = &TSQLSTRU[FETCH_AREA]->tValuepb[i];
        switch ( sql_value->type ) {
             case DFFAPDATE:
             case DFFAPDTIME:
             case DFFAPINTERVAL:
             case DFFAPCHAR:
             case DFFAPVCHAR:
             case DFFAPLONG:
             case DFFAPVCHAR2:
                  STRALIGN( p , sizeof( char ) );
                  Db2GetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( char ) * ( sql_value->cb + 1 ));
                  break;
             case DFFAPTEXT:
             case DFFAPBYTES:
                  STRALIGN( p , sizeof( char ) );
                  Db2GetData( i , p , DEF_CHAR_LEN );
                  p = (void *)((long)p + sizeof( char ) * ( DEF_CHAR_LEN + 1 ));
                  break;
             case DFFAPSMINT:
                  STRALIGN( p , sizeof( short ) );
                  Db2GetData( i , p , sizeof( short ) );
                  p = (void *)((long)p + sizeof( short ));
                  break;
             case DFFAPINTEGER:
/* 20051019 统一按long处理，方便移植
                  STRALIGN( p , sizeof( int ) );
                  Db2GetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( int ));
                  break;
*/
             case DFFAPINT:
                  STRALIGN( p , sizeof( long ) );
                  Db2GetData( i , p , sizeof( long ) );
                  p = (void *)((long)p + sizeof( long ));
                  break;
             case DFFAPDECIMAL:
             case DFFAPFLOAT:
                  STRALIGN( p , sizeof( double ) );
                  Db2GetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( double ));
                  break;
             case DFFAPSMFLOAT:
                  STRALIGN( p , sizeof( float ) );
                  Db2GetData( i , p , sql_value->cb );
                  p = (void *)((long)p + sizeof( float ));
                  break;
        }
/* 长度 = sizeof ( STRUCT ) */
        if( (long)p - (long)_data >= _len )
            break;
    }
    return( E_OK );
}

/* 20051027 支持批量处理insert/update提高效率 */
int
Db2SqlBatExec ( int _area , char * _statement )
{
    char        prepname[15];
    char        descname[15];
    int         ret;
    int         alloc_num;
    int         i;
    char        str_tmp[128];

    FAP_SQLCODE = 0;
    sprintf(prepname,"%d",_area);
    sprintf(descname,"%d",_area);

    if ( TSQLSTRU == NULL )
        APP_ERR( E_DB_NOOPEN )

    if ( _area >= MAX_AREA || TSQLSTRU[_area] == NULL ) {
        sprintf( str_tmp , "work area [%d] not calloc" , _area );
        bclerreg( E_INVALARG, _FL_, str_tmp );
        return E_FAIL;
    }

/* 已prepare的工作区可直接继续Exec */
    if ( !TSQLSTRU[_area]->tsqlstat.prep_stat ) {
        alloc_num = get_comma_num( _statement , ',' )+1;
        ret = Db2SqlPrepare( TSQLSTRU[_area] , prepname, _statement );
        if ( ret != E_OK ) {
            bclerreg( E_SQL , _FL_ ,"Db2SqlPrepare err.");
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

        if ( alloc_num < DEF_ALLOC_NUM )
            alloc_num = DEF_ALLOC_NUM;
        else if( TSQLSTRU[_area]->tsqlstat.alloc_stat ) {
            Db2SqlDealloc( TSQLSTRU[_area] );
            TSQLSTRU[_area]->tsqlstat.alloc_stat = 0;
        }

        ret = Db2SqlAllocate( TSQLSTRU[_area] , descname , alloc_num );
        if ( ret != E_OK ) {
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

        /* 取?个数和填充INPUT SQLDA */
        ret = Db2SqlDescribe( TSQLSTRU[_area], '0' );
        if( ret != E_OK ) {
            TSQLSTRU[_area]->sql_code = 0;
            TSQLSTRU[_area]->user_code = 0;
            return ret;
        }

/* 为查询条件赋值 */
        if( TSQLSTRU[_area]->ques_num != 0 )  {
            ret = AllocValueBuf( TSQLSTRU[_area] , TSQLSTRU[_area]->ques_num );
            if ( ret != E_OK ) {
                bclerreg( E_SQL , _FL_ ,"AllocValueBuf err.");
                TSQLSTRU[_area]->sql_code = 0;
                TSQLSTRU[_area]->user_code = 0;
                return ret;
            }

            for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
                memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ], \
                        sizeof( tSqlValue ) );
                ret = Db2SqlPutValue( TSQLSTRU[_area] , (short)i );
                if ( ret != E_OK ) {
                    bclerreg( E_SQL , _FL_ ,"Db2SqlPutValue err.");
                    TSQLSTRU[_area]->sql_code = 0;
                    TSQLSTRU[_area]->user_code = 0;
                    return ret;
                }
            } /* end of for */

        } /* end of if ques_num */

    } /* end of if prep_stat */
    else
        for( i=1; i <= TSQLSTRU[_area]->ques_num; i++ )  {
            memcpy( &TSQLSTRU[_area]->tValuepb[i-1] , &TSQLVarPool[ i-1 ], \
                    sizeof( tSqlValue ) );
            ret = Db2SqlPutValue( TSQLSTRU[_area] , (short)i );
            if ( ret != E_OK ) {
                bclerreg( E_SQL , _FL_ ,"Db2SqlPutValue err.");
                TSQLSTRU[_area]->sql_code = 0;
                TSQLSTRU[_area]->user_code = 0;
                return ret;
            }
        } /* end of for */
    ret = Db2SqlExecute( TSQLSTRU[_area] );
    TSQLSTRU[_area]->tsqlstat.put_stat = 0;
    TSQLSTRU[_area]->sql_code = 0;
    TSQLSTRU[_area]->user_code = 0;
    if ( ret == E_FAIL ) {
        bclerreg( E_SQL , _FL_ ,"Db2SqlExecute err.");
        return ret;
    }

    if ( TSQLSTRU[_area]->proc_row == 0 )
       return E_NOTFOUND;
    return E_OK;
}
